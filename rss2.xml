<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>π square</title>
    <link>http://xuyangyang.xyz/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>闲言碎语，七拼八凑</description>
    <pubDate>Fri, 01 Dec 2017 16:24:23 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>Golang fmt.Printf 的格式化占位符</title>
      <link>http://xuyangyang.xyz/2017/11/29/Golang-fmt-Printf-%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%8D%A0%E4%BD%8D%E7%AC%A6/</link>
      <guid>http://xuyangyang.xyz/2017/11/29/Golang-fmt-Printf-%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%8D%A0%E4%BD%8D%E7%AC%A6/</guid>
      <pubDate>Wed, 29 Nov 2017 01:30:03 GMT</pubDate>
      <description>
      
        &lt;p&gt;&amp;emsp; &amp;emsp;今天看Golang fmt&lt;a href=&quot;https://golang.org/pkg/fmt/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;官方文档&lt;/a&gt;，看到了占位符的相关内容，记录下。  &lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>&emsp; &emsp;今天看Golang fmt<a href="https://golang.org/pkg/fmt/" target="_blank" rel="external">官方文档</a>，看到了占位符的相关内容，记录下。  </p><a id="more"></a><p>&emsp; &emsp; Golang的占位符与C语言的占位符很类似，但是要精简的多。下面按照数据类型作为分类标准，介绍下各个占位符的使用。  </p><ul><li><p>通用占位符<br>&emsp; &emsp;Golang使用“%v”作为一个“万能”的占位符，编译器可以根据数据类型自动推断最终的数据展示格式。但是，这个通用占位符还是有定制的空间的。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># 示例数据</div><div class="line"><span class="keyword">type</span> animal <span class="keyword">struct</span> &#123;</div><div class="line">  name <span class="keyword">string</span></div><div class="line">  age  <span class="keyword">int</span></div><div class="line">&#125;</div><div class="line">cat := animal&#123;name: <span class="string">"kitty"</span>, age: <span class="number">3</span>&#125;</div></pre></td></tr></table></figure></li></ul><table><thead><tr><th style="text-align:center">占位符</th><th style="text-align:center">说明</th><th style="text-align:center">示例</th><th style="text-align:center">输出</th></tr></thead><tbody><tr><td style="text-align:center">%v</td><td style="text-align:center">输出默认格式</td><td style="text-align:center"><code>fmt.Printf(&quot;%v&quot;, cat)</code></td><td style="text-align:center">{kitty 3}</td></tr><tr><td style="text-align:center">%+v</td><td style="text-align:center">为struct类型添加字段名称</td><td style="text-align:center"><code>fmt.Printf(&quot;%+v&quot;, cat)</code></td><td style="text-align:center">{name:kitty age:3}</td></tr><tr><td style="text-align:center">%#v</td><td style="text-align:center">输出完整语法表示</td><td style="text-align:center"><code>fmt.Printf(&quot;%#v&quot;, cat)</code></td><td style="text-align:center">main.animal{name:”kitty”, age:3}</td></tr><tr><td style="text-align:center">%T</td><td style="text-align:center">打印数据类型</td><td style="text-align:center"><code>fmt.Printf(&quot;%T&quot;, cat)</code></td><td style="text-align:center">main.animal</td></tr><tr><td style="text-align:center">%%</td><td style="text-align:center">打印百分号%</td><td style="text-align:center"><code>fmt.Printf(&quot;%%&quot;)</code></td><td style="text-align:center">%</td></tr></tbody></table><p>   &emsp;&emsp;除了上述通用的占位符，针对各个不同的数据类型，Golang有相应的专用占位符。</p><ul><li>布尔型<br>&emsp;&emsp;针对布尔型的数据，如果想要打印”true”或”false”, 可以使用%t作为占位符。  </li></ul><table><thead><tr><th style="text-align:center">占位符</th><th style="text-align:center">说明</th><th style="text-align:center">示例</th><th style="text-align:center">输出</th></tr></thead><tbody><tr><td style="text-align:center">%t</td><td style="text-align:center">输出true或false</td><td style="text-align:center"><code>fmt.Printf(&quot;%t&quot;,ture)</code></td><td style="text-align:center">true</td></tr></tbody></table><ul><li>整型</li></ul><table><thead><tr><th style="text-align:center">占位符</th><th style="text-align:center">说明</th><th style="text-align:center">示例</th><th style="text-align:center">输出</th></tr></thead><tbody><tr><td style="text-align:center">%b</td><td style="text-align:center">二进制表示</td><td style="text-align:center"><code>fmt.Printf(&quot;%b&quot;, 233)</code></td><td style="text-align:center">11101001</td></tr><tr><td style="text-align:center">%o</td><td style="text-align:center">八进制表示</td><td style="text-align:center"><code>fmt.Printf(&quot;%o&quot;, 233)</code></td><td style="text-align:center">351</td></tr><tr><td style="text-align:center">%d</td><td style="text-align:center">十进制表示</td><td style="text-align:center"><code>fmt.Printf(&quot;%d&quot;, 0351)</code></td><td style="text-align:center">233</td></tr><tr><td style="text-align:center">%x</td><td style="text-align:center">十六进制表示(小写字母)</td><td style="text-align:center"><code>fmt.Printf(&quot;%x&quot;, 233)</code></td><td style="text-align:center">e9</td></tr><tr><td style="text-align:center">%X</td><td style="text-align:center">十六进制表示(大写字母)</td><td style="text-align:center"><code>fmt.Printf(&quot;%X&quot;, 233)</code></td><td style="text-align:center">E9</td></tr><tr><td style="text-align:center">%c</td><td style="text-align:center">Unicode码点对于的字符</td><td style="text-align:center"><code>fmt.Printf(&quot;%c&quot;, 0x75D2)</code></td><td style="text-align:center">痒</td></tr><tr><td style="text-align:center">%U</td><td style="text-align:center">输出Unicode,等价于”U+%04X”</td><td style="text-align:center"><code>fmt.Printf(&quot;%U&quot;, &#39;痒&#39;)</code></td><td style="text-align:center">0x75D2</td></tr></tbody></table><ul><li>浮点型和复数</li></ul><table><thead><tr><th style="text-align:center">占位符</th><th style="text-align:center">说明</th><th style="text-align:center">示例</th><th style="text-align:center">输出</th></tr></thead><tbody><tr><td style="text-align:center">%b</td><td style="text-align:center">无小数部分，指数基数为二的科学计数法</td><td style="text-align:center"><code>fmt.Printf(&quot;%b&quot;, 65536.0)</code></td><td style="text-align:center">4503606499318170p-36</td></tr><tr><td style="text-align:center">%e</td><td style="text-align:center">科学计数法</td><td style="text-align:center"><code>fmt.Printf(&quot;%e&quot;, 65536.0)</code></td><td style="text-align:center">6.553610e+04</td></tr><tr><td style="text-align:center">%E</td><td style="text-align:center">科学计数法</td><td style="text-align:center"><code>fmt.Printf(&quot;%e&quot;, 65536.0)</code></td><td style="text-align:center">6.553610E+04</td></tr><tr><td style="text-align:center">%f</td><td style="text-align:center">没有指数的小数</td><td style="text-align:center"><code>fmt.Printf(&quot;%f&quot;, 65536.1)</code></td><td style="text-align:center">65536.1</td></tr><tr><td style="text-align:center">%F</td><td style="text-align:center">没有指数的小数</td><td style="text-align:center"><code>fmt.Printf(&quot;%F&quot;, 65536.1)</code></td><td style="text-align:center">65536.1</td></tr><tr><td style="text-align:center">%g</td><td style="text-align:center">以更紧凑的方式自动选择%e或%f(末尾无0)</td><td style="text-align:center"><code>fmt.Printf(&quot;%g&quot;, 65536.1)</code></td><td style="text-align:center">65536.1</td></tr><tr><td style="text-align:center">%G</td><td style="text-align:center">以更紧凑的方式自动选择%E或%f(末尾无0)</td><td style="text-align:center"><code>fmt.Printf(&quot;%G&quot;, 65536.1)</code></td><td style="text-align:center">65536.1</td></tr><tr><td style="text-align:center">%2.1g</td><td style="text-align:center">输出结果宽度2(左侧补空格),结果共1位数字</td><td style="text-align:center"><code>fmt.Printf(&quot;%2.1g&quot;, 1.21)</code></td><td style="text-align:center">1(左侧有一空格)</td></tr><tr><td style="text-align:center">%2.1f</td><td style="text-align:center">输出结果共2位(左侧补空格),小数1位</td><td style="text-align:center"><code>fmt.Printf(&quot;%2.1f&quot;, 1.21)</code></td><td style="text-align:center">1.2</td></tr></tbody></table><ul><li>字符串及字节切片</li></ul><table><thead><tr><th style="text-align:center">占位符</th><th style="text-align:center">说明</th><th style="text-align:center">示例</th><th style="text-align:center">输出</th></tr></thead><tbody><tr><td style="text-align:center">%s</td><td style="text-align:center">字符串表示</td><td style="text-align:center"><code>fmt.Printf(&quot;%s&quot;, &quot;hello, world&quot;)</code></td><td style="text-align:center">hello, world</td></tr><tr><td style="text-align:center">%q</td><td style="text-align:center">带双引号的字符串表示</td><td style="text-align:center"><code>fmt.Printf(&quot;%q&quot;, &quot;hello, world&quot;)</code></td><td style="text-align:center">“hello, world”</td></tr><tr><td style="text-align:center">%x</td><td style="text-align:center">对字节序列的十六进制表示(小写字母)</td><td style="text-align:center"><code>fmt.Printf(&quot;%x&quot;, &quot;hello, world&quot;)</code></td><td style="text-align:center">68656c6c6f2c20776f726c64</td></tr><tr><td style="text-align:center">%X</td><td style="text-align:center">对字节序列的十六进制表示(大写字母)</td><td style="text-align:center"><code>fmt.Printf(&quot;X%&quot;, &quot;hello, world&quot;)</code></td><td style="text-align:center">68656C6C6F2C20776F726C64</td></tr></tbody></table><ul><li>指针</li></ul><table><thead><tr><th style="text-align:center">占位符</th><th style="text-align:center">说明</th><th style="text-align:center">示例</th><th style="text-align:center">输出</th></tr></thead><tbody><tr><td style="text-align:center">%p</td><td style="text-align:center">十六进制表示指针值, 0x打头</td><td style="text-align:center"><code>fmt.Printf(&quot;%p&quot;, &amp;var)</code></td><td style="text-align:center">0xc4200160c8</td></tr></tbody></table><ul><li>再探通用占位符<br>对于，各数据类型，通用占位符对应的特定占位符为：</li></ul><table><thead><tr><th style="text-align:left">数据类型</th><th style="text-align:center">对应的特定占位符</th></tr></thead><tbody><tr><td style="text-align:left">bool</td><td style="text-align:center">%t</td></tr><tr><td style="text-align:left">int, int8等</td><td style="text-align:center">%d</td></tr><tr><td style="text-align:left">uint, uint8等</td><td style="text-align:center">%d 或%#v(%#v)</td></tr><tr><td style="text-align:left">float32, complex64等</td><td style="text-align:center">%g</td></tr><tr><td style="text-align:left">string</td><td style="text-align:center">%s</td></tr><tr><td style="text-align:left">chan</td><td style="text-align:center">%p</td></tr><tr><td style="text-align:left">指针</td><td style="text-align:center">%p</td></tr><tr><td style="text-align:left">struct</td><td style="text-align:center">{field0 field1…}</td></tr><tr><td style="text-align:left">array, slice</td><td style="text-align:center">[elem0 elem1…]</td></tr><tr><td style="text-align:left">maps</td><td style="text-align:center">map[key1:valule1 key2:value2]</td></tr><tr><td style="text-align:left">struct,array,slice,maps 指针</td><td style="text-align:center">&amp;{}, &amp;[], &amp;map[]</td></tr></tbody></table><ul><li>占位符辅助标识<ul><li>+: 打印数值正负号  </li><li>-: 在右侧填充空格  </li><li>#: 为八进制/十六进制添加前缀; %#p将去掉0x前缀;%#q将打印原始字符串(若有单引号则输出)  </li><li>0: 用0而非空格填充  </li><li>空格: % d将用空格代替原本的正负号; % x或% X打印字符串或字节切片时，字节直接将以空格分隔  </li></ul></li></ul>]]></content:encoded>
      
      <comments>http://xuyangyang.xyz/2017/11/29/Golang-fmt-Printf-%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%8D%A0%E4%BD%8D%E7%AC%A6/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Golang结构体方法</title>
      <link>http://xuyangyang.xyz/2017/11/27/Golang%E7%BB%93%E6%9E%84%E4%BD%93%E6%96%B9%E6%B3%95/</link>
      <guid>http://xuyangyang.xyz/2017/11/27/Golang%E7%BB%93%E6%9E%84%E4%BD%93%E6%96%B9%E6%B3%95/</guid>
      <pubDate>Mon, 27 Nov 2017 14:28:02 GMT</pubDate>
      <description>
      
        &lt;p&gt;&amp;emsp;&amp;emsp;在Golang 中，通过为结构体绑定方法，可以令其扮演Java中“类”的角色。举个简单的例子：&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>&emsp;&emsp;在Golang 中，通过为结构体绑定方法，可以令其扮演Java中“类”的角色。举个简单的例子：<br><a id="more"></a></p><pre><code><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">type</span> animal <span class="keyword">interface</span> &#123;</div><div class="line">  Speak()</div><div class="line">  Sing()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">type</span> cat <span class="keyword">struct</span> &#123;</div><div class="line">  name <span class="keyword">string</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cat)</span> <span class="title">Speak</span><span class="params">()</span></span> &#123;</div><div class="line">  fmt.Printf(<span class="string">"I am %v\n"</span>, c.name)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c cat)</span> <span class="title">Sing</span><span class="params">()</span></span> &#123;</div><div class="line">  fmt.Printf(<span class="string">"Meow~ Meow~~ Meow~~~ %v is me\n"</span>, c.name)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">  kitty := &amp;cat&#123;name: <span class="string">"kitty"</span>&#125;</div><div class="line">  kitty.Speak()</div><div class="line">  kitty.Sing()</div><div class="line"></div><div class="line">  alice := cat&#123;name: <span class="string">"alice"</span>&#125;</div><div class="line">  alice.Speak()</div><div class="line">  alice.Sing()</div><div class="line">&#125;</div><div class="line"></div><div class="line">#输出结果：</div><div class="line">I am kitty</div><div class="line">Meow~ Meow~~ Meow~~~ kitty is me</div><div class="line">I am alice</div><div class="line">Meow~ Meow~~ Meow~~~ alice is me</div></pre></td></tr></table></figure></code></pre><p>&emsp;&emsp;我们可以将方法绑定到struct对象或者对象指针上，概括起来：通过值类型或引用类型来定义方法。无论使用哪种方式，在使用的时候，Golang可以帮我们完成类型的转换，即：我们可以用指针对象调用值类型的方法，也可以用值类型调用绑定在引用类型上的方法。引用类型定义方法有两个好处：</p><ol><li>可以减少对“大”对象的复制，某些情况下可以提高效率</li><li>可以修改绑定的struct对象的字段  </li></ol><p>&emsp;&emsp;再来个例子：<br>     <figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">type</span> animal <span class="keyword">interface</span> &#123;</div><div class="line">  Speak()</div><div class="line">  Sing()</div><div class="line">  SetName(name <span class="keyword">string</span>)</div><div class="line">  SetAge(age <span class="keyword">int</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">type</span> cat <span class="keyword">struct</span> &#123;</div><div class="line">  name <span class="keyword">string</span></div><div class="line">  age  <span class="keyword">int</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cat)</span> <span class="title">Speak</span><span class="params">()</span></span> &#123;</div><div class="line">  fmt.Printf(<span class="string">"I am %v &amp; I am %v years old\n"</span>, c.name, c.age)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c cat)</span> <span class="title">Sing</span><span class="params">()</span></span> &#123;</div><div class="line">  fmt.Printf(<span class="string">"Meow~ Meow~~ Meow~~~ %v is me\n"</span>, c.name)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cat)</span> <span class="title">SetName</span><span class="params">(name <span class="keyword">string</span>)</span></span> &#123;</div><div class="line">  c.name = name</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c cat)</span> <span class="title">SetAge</span><span class="params">(age <span class="keyword">int</span>)</span></span> &#123;</div><div class="line">  c.age = age</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">  kitty := &amp;cat&#123;name: <span class="string">"kitty"</span>, age: <span class="number">1</span>&#125;</div><div class="line">  kitty.Speak()</div><div class="line">  kitty.SetName(<span class="string">"hello kitty"</span>)</div><div class="line">  kitty.SetAge(<span class="number">3</span>)</div><div class="line">  kitty.Speak()</div><div class="line">&#125;</div><div class="line"></div><div class="line">输出结果：</div><div class="line">I am kitty &amp; I am <span class="number">1</span> years old</div><div class="line">I am hello kitty &amp; I am <span class="number">1</span> years old</div></pre></td></tr></table></figure></p><p>&emsp;&emsp;上例中，SetName是定义在引用类型上的，SetAge是定义在值类型上的。那么，对“kitty”对象调用这两个方法，只有SetName成功的修改了kitty的字段值。<br>&emsp;&emsp;既然提到了struct实现interface方法，那么再额外探索下interface机制。<br>    <figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">type</span> animal <span class="keyword">interface</span> &#123;</div><div class="line">  Speak()</div><div class="line">  Sing()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">type</span> cat <span class="keyword">struct</span> &#123;</div><div class="line">  name <span class="keyword">string</span></div><div class="line">  age  <span class="keyword">int</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cat)</span> <span class="title">Speak</span><span class="params">()</span></span> &#123;</div><div class="line">  fmt.Printf(<span class="string">"I am %v &amp; I am %v years old\n"</span>, c.name, c.age)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c cat)</span> <span class="title">Sing</span><span class="params">()</span></span> &#123;</div><div class="line">  fmt.Println(<span class="string">"Meow~ Meow!"</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">DoSpeak</span><span class="params">(baby animal)</span></span> &#123;</div><div class="line">  baby.Speak()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">DoSing</span><span class="params">(baby animal)</span></span> &#123;</div><div class="line">  baby.Sing()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">  kitty := &amp;cat&#123;name: <span class="string">"kitty"</span>, age: <span class="number">1</span>&#125;</div><div class="line">  DoSpeak(kitty)</div><div class="line">  DoSing(kitty)</div><div class="line"></div><div class="line">  alice := cat&#123;name: <span class="string">"alice"</span>, age: <span class="number">2</span>&#125;</div><div class="line">  DoSpeak(alice)</div><div class="line">  DoSing(alice)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>&emsp;&emsp;上述代码是无法通过编译的，报错信息如下：    </p><blockquote><p>./main4.go:37:10: cannot use alice (type cat) as type animal in argument to DoSpeak: cat does not implement animal (Speak method has pointer receiver)<br>./main4.go:38:9: cannot use alice (type cat) as type animal in argument to DoSing: cat does not implement animal (Speak method has pointer receiver)  </p></blockquote><p>&emsp;&emsp;我在<a href="http://xuyangyang.xyz/2017/11/16/Golang%E2%80%9C%E7%BB%A7%E6%89%BF%E2%80%9D/">这篇文章</a>里也遇到了这个问题，这里一并记录下。<br>&emsp;&emsp;报错信息的意思是alice对象并没有实现animal接口，但是好奇怪呃，struct已经是实现了animal接口了才对。这里就是比较trick的地方了。按照上面的例子来看，我以为绑定到struct对象和对象指针上的方法效果是一样的，其实不然。一旦涉及到使用interface的“多态性”，事情就变味了，某些“本质”的东西就暴露出来了。<br>&emsp;&emsp; Golang中，值类型的对象实际上只会有定义在值类型上的方法；引用类型的对象同时拥有定义在引用类型上的方法和定义在值类型上的方法。那么疑问来了，为啥刚才值类型对象可以调用定义在引用类型上的方法呢，Golang的编译器比较“智能”，它主动帮忙把对象类型转成了&amp;引用的形式来调用相应的方法，但是实际上，值类型还是没有引用类型的方法。<br>&emsp;&emsp;由此可见，只有用引用类型去实现接口时，才算是“真正低”实现该接口（无论值类型还是引用类型都可以调用相应的方法）；倘若用值类型来实现接口，那么，引用类型是没有相应的方法的，也就是没有实现相应的接口了。这就解释了为啥alice没有实现animal接口了，因为Speak方法是定义在struct引用类型上的，作为值类型的alice是不会拥有Speak方法滴。与此相反，虽然Sing方法是定义在值类型上的，但是由于kitty是引用类型，它还是拥有该方法的。  </p><p>以上。</p>]]></content:encoded>
      
      <comments>http://xuyangyang.xyz/2017/11/27/Golang%E7%BB%93%E6%9E%84%E4%BD%93%E6%96%B9%E6%B3%95/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Golang“继承”</title>
      <link>http://xuyangyang.xyz/2017/11/16/Golang%E2%80%9C%E7%BB%A7%E6%89%BF%E2%80%9D/</link>
      <guid>http://xuyangyang.xyz/2017/11/16/Golang%E2%80%9C%E7%BB%A7%E6%89%BF%E2%80%9D/</guid>
      <pubDate>Thu, 16 Nov 2017 06:28:12 GMT</pubDate>
      <description>
      
        &lt;p&gt;&amp;emsp;&amp;emsp;声明：本文受文章&lt;a href=&quot;http://hackthology.com/golangzhong-de-mian-xiang-dui-xiang-ji-cheng.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Golang中的面向对象继承&lt;/a&gt;启发，整理而来。&lt;br&gt;&amp;emsp;&amp;emsp;Golang 并不是一门面向对象的语言，自然也就没有“继承”的概念。但是，从Java转到Golang，还是有办法实现extends的。&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>&emsp;&emsp;声明：本文受文章<a href="http://hackthology.com/golangzhong-de-mian-xiang-dui-xiang-ji-cheng.html" target="_blank" rel="external">Golang中的面向对象继承</a>启发，整理而来。<br>&emsp;&emsp;Golang 并不是一门面向对象的语言，自然也就没有“继承”的概念。但是，从Java转到Golang，还是有办法实现extends的。<br><a id="more"></a><br>&emsp;&emsp;Golang中实现继承主要是借助“嵌入”（embeded）来完成的，通过在“子类”中嵌入“父类”的匿名字段来完成目的。<br>    <figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"><span class="keyword">import</span> (</div><div class="line">  <span class="string">"fmt"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">type</span> Base <span class="keyword">struct</span> &#123;</div><div class="line">  name <span class="keyword">string</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Base)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</div><div class="line">  <span class="keyword">return</span> <span class="string">"hello, I am "</span> + b.name</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">type</span> Sub <span class="keyword">struct</span> &#123;</div><div class="line">  Base</div><div class="line">  age <span class="keyword">int</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Sub)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</div><div class="line">  <span class="keyword">return</span> s.Base.String() + fmt.Sprintf(<span class="string">" &amp; I am %v years old"</span>, s.age)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">  foo := Sub&#123;Base: Base&#123;name: <span class="string">"alice"</span>&#125;, age: <span class="number">3</span>&#125;</div><div class="line">  fmt.Println(foo.String())</div><div class="line">&#125;  </div><div class="line">输出结果：</div><div class="line">hello, I am alice &amp; I am <span class="number">3</span> years old</div></pre></td></tr></table></figure></p><p>&emsp;&emsp;利用struct的嵌入，可以实现基本的重载特性，子类可以重用父类的字段及方法。例如上例中Sub类拥有父类的name字段，并重写了父类的String方法。但是这种实现重载的方式有个问题。如果被重载的方法时被另外的方法调用的，那么，调用结果就会与预期不符。例如：<br>    package main<br>    <figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> (</div><div class="line">  <span class="string">"fmt"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">type</span> Base <span class="keyword">struct</span> &#123;</div><div class="line">  name <span class="keyword">string</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Base)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</div><div class="line">  <span class="keyword">return</span> <span class="string">"hello, I am "</span> + b.name</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Base)</span> <span class="title">Print</span><span class="params">()</span></span> &#123;</div><div class="line">  fmt.Println(b.String())</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">type</span> Sub <span class="keyword">struct</span> &#123;</div><div class="line">  Base</div><div class="line">  age <span class="keyword">int</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Sub)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</div><div class="line">  <span class="keyword">return</span> s.Base.String() + fmt.Sprintf(<span class="string">" &amp; I am %v years old"</span>, s.age)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">  foo := Sub&#123;Base: Base&#123;name: <span class="string">"alice"</span>&#125;, age: <span class="number">3</span>&#125;</div><div class="line">  fmt.Println(foo.String())</div><div class="line">  foo.Print()</div><div class="line">&#125;</div><div class="line">输出结果：</div><div class="line">hello, I am alice &amp; I am <span class="number">3</span> years old</div><div class="line">hello, I am alice</div></pre></td></tr></table></figure></p><p>&emsp;&emsp;我们在父类Base中加入了一个Print方法。从Java的开发经验来预测，我们期望的输出结果应该是：<br>    hello, I am alice &amp; I am 3 years old<br>    hello, I am alice &amp; I am 3 years old<br>即：Print方法应该是具有“动态绑定”的特性，可以动态地选择它所调用的String方法。子类Sub虽然拥有从父类Base继承来的Print方法，但是这个Print方法时父类带有父类“特征”的，它是和父类的String方法强绑定的。Golang 从根本上阻止了抽象方法的使用 那么，有无破解之道呢？先看代码：<br>    <figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"><span class="keyword">import</span> (</div><div class="line">  <span class="string">"fmt"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">type</span> I <span class="keyword">interface</span> &#123;</div><div class="line">  String() <span class="keyword">string</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">type</span> Base <span class="keyword">struct</span> &#123;</div><div class="line">  i    I</div><div class="line">  name <span class="keyword">string</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Base)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</div><div class="line">  <span class="keyword">return</span> <span class="string">"hello, I am "</span> + b.name</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Base)</span> <span class="title">Print</span><span class="params">()</span></span> &#123;</div><div class="line">  fmt.Println(b.i.String())</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">type</span> Sub <span class="keyword">struct</span> &#123;</div><div class="line">  Base</div><div class="line">  age <span class="keyword">int</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Sub)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</div><div class="line">  <span class="keyword">return</span> s.Base.String() + fmt.Sprintf(<span class="string">" &amp; I am %v years old"</span>, s.age)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">  foo := Sub&#123;Base: Base&#123;name: <span class="string">"alice"</span>&#125;, age: <span class="number">3</span>&#125;</div><div class="line">  foo.i = &amp;foo</div><div class="line">  fmt.Println(foo.String())</div><div class="line">  foo.Print()</div><div class="line">&#125;</div><div class="line">输出结果：</div><div class="line">hello, I am alice &amp; I am <span class="number">3</span> years old</div><div class="line">hello, I am alice &amp; I am <span class="number">3</span> years old</div></pre></td></tr></table></figure></p><p>&emsp;&emsp;将String方法作为interface封装起来，将interface作为父类的一个属性，然后在Print方法中通过对interface属性的调用，完成原有功能。总结起来，解决办法是将需要重载的方法作为一个“属性”，这样就可以通过对其动态赋值，达到动态选择的目的了。没办法，只有这种曲线救国的方法可以达到对重载方法的动态选择的目的了。<br>&emsp;&emsp;可是，还有一个问题。按照“面向对象”的思想，子类继承父类，那么任何需要父类的地方，按理说都可以用子类来代替。子类是父类的特化嘛，这不就是“多态”嘛？很遗憾，Golang又让你失望了。<br>    <figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"><span class="keyword">import</span> (</div><div class="line">  <span class="string">"fmt"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">type</span> I <span class="keyword">interface</span> &#123;</div><div class="line">  String() <span class="keyword">string</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">type</span> Base <span class="keyword">struct</span> &#123;</div><div class="line">  i    I</div><div class="line">  name <span class="keyword">string</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Base)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</div><div class="line">  <span class="keyword">return</span> <span class="string">"hello, I am "</span> + b.name</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Base)</span> <span class="title">Print</span><span class="params">()</span></span> &#123;</div><div class="line">  fmt.Println(b.i.String())</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">type</span> Sub <span class="keyword">struct</span> &#123;</div><div class="line">  Base</div><div class="line">  age <span class="keyword">int</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Sub)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</div><div class="line">  <span class="keyword">return</span> s.Base.String() + fmt.Sprintf(<span class="string">" &amp; I am %v years old"</span>, s.age)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">Info</span><span class="params">(b Base)</span></span> &#123;</div><div class="line">  b.Print()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">  foo := Sub&#123;Base: Base&#123;name: <span class="string">"alice"</span>&#125;, age: <span class="number">3</span>&#125;</div><div class="line">  foo.i = &amp;foo</div><div class="line">  Info(foo)</div><div class="line">&#125;</div><div class="line">输出结果：</div><div class="line">cannot use foo (<span class="keyword">type</span> Sub) as <span class="keyword">type</span> Base in argument to Info</div></pre></td></tr></table></figure></p><p>&emsp;&emsp;呵呵哒，剧本貌似不是这么写的。没办法吗？提前剧透：Golang的接口类型有子类化的多态机制。所以，再次曲线救国吧~<br>    <figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"><span class="keyword">import</span> (</div><div class="line">  <span class="string">"fmt"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">type</span> I <span class="keyword">interface</span> &#123;</div><div class="line">  String() <span class="keyword">string</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">type</span> iBase <span class="keyword">interface</span>&#123;</div><div class="line">  String() <span class="keyword">string</span></div><div class="line">  Print()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">type</span> Base <span class="keyword">struct</span> &#123;</div><div class="line">  i    I</div><div class="line">  name <span class="keyword">string</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Base)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</div><div class="line">  <span class="keyword">return</span> <span class="string">"hello, I am "</span> + b.name</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Base)</span> <span class="title">Print</span><span class="params">()</span></span> &#123;</div><div class="line">  fmt.Println(b.i.String())</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">type</span> Sub <span class="keyword">struct</span> &#123;</div><div class="line">  Base</div><div class="line">  age <span class="keyword">int</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Sub)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</div><div class="line">  <span class="keyword">return</span> s.Base.String() + fmt.Sprintf(<span class="string">" &amp; I am %v years old"</span>, s.age)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">Info</span><span class="params">(b iBase)</span></span> &#123;</div><div class="line">  b.Print()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">  foo := Sub&#123;Base: Base&#123;name: <span class="string">"alice"</span>&#125;, age: <span class="number">3</span>&#125;</div><div class="line">  foo.i = &amp;foo</div><div class="line">  Info(&amp;foo)</div><div class="line">&#125;</div><div class="line">输出结果：</div><div class="line">hello, I am alice &amp; I am <span class="number">3</span> years old</div></pre></td></tr></table></figure></p><p>&emsp;&emsp;把父类对应的方法都封装到interface里吧，让父类去实现这个接口。子类如果需要“扩展”方法，同样可以利用嵌入的方式，生成子类自己的接口。这样就可以利用接口来实现继承中的多态了。注意，Info方法的参数是iBase接口，在用子类对象foo调用这个方法时，需要传递foo对象的引用。为了这个纠结了好久，这个问题回头另起一篇记录下。  </p><p>以上。</p>]]></content:encoded>
      
      <comments>http://xuyangyang.xyz/2017/11/16/Golang%E2%80%9C%E7%BB%A7%E6%89%BF%E2%80%9D/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Tips in Golang</title>
      <link>http://xuyangyang.xyz/2017/11/15/Tips-in-Golang/</link>
      <guid>http://xuyangyang.xyz/2017/11/15/Tips-in-Golang/</guid>
      <pubDate>Wed, 15 Nov 2017 09:16:37 GMT</pubDate>
      <description>
      
        &lt;p&gt;&amp;emsp;&amp;emsp;新人Golang入门，记录下平时遇到的小姿势，供以后回顾。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>&emsp;&emsp;新人Golang入门，记录下平时遇到的小姿势，供以后回顾。</p><a id="more"></a><ol><li><p>slice &amp; append  </p><pre><code><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo, bar \[]T</div><div class="line"><span class="keyword">var</span> elem T</div></pre></td></tr></table></figure></code></pre><ul><li>将elem添加到foo中： <code>foo=append(foo, elem)</code></li><li>将bar添加到foo中： <code>foo=append(foo,bar...)</code></li><li>将bar复制到一个名为a的slice中：<code>a:=make([]T,len(bar));copy(a,bar)</code></li><li>从bar中删除下标为i的元素（假定不会越界）：<code>bar=append(bar[:i],bar[i+1]...)</code></li><li>从bar中删除下标i到j的元素（假定不会越界）：<code>bar=append(bar[:i],bar[j+1]...)</code></li><li>将bar扩展长度为j的容量：<code>bar=append(bar,make([]T,j)...)</code></li><li>在bar的下标为i处插入长度为j的slice：<code>bar=append(bar[:i],append(make([]T,j),a[i:]...)...)</code></li><li>在bar的下标为i处插入foo：<code>bar=append(a[:i],append(b,a[i:]...)...)</code></li><li>返回并删除bar中下标最高的元素：<code>x,foo=foo[len(foo)-1],a[:len(foo)-1]</code>  </li></ul></li></ol><p>以上。</p>]]></content:encoded>
      
      <comments>http://xuyangyang.xyz/2017/11/15/Tips-in-Golang/#disqus_thread</comments>
    </item>
    
    <item>
      <title>golang 字符串拼接</title>
      <link>http://xuyangyang.xyz/2017/11/15/golang-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5/</link>
      <guid>http://xuyangyang.xyz/2017/11/15/golang-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5/</guid>
      <pubDate>Wed, 15 Nov 2017 02:41:47 GMT</pubDate>
      <description>
      
        &lt;p&gt;&amp;emsp;&amp;emsp; Golang中的字符串拼接方式“大概”有4种：&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>&emsp;&emsp; Golang中的字符串拼接方式“大概”有4种：</p><a id="more"></a><ol><li>+ </li><li>fmt.Sprintf</li><li>strings.Join</li><li>bytes.Buffer</li></ol><p>&emsp;&emsp;好多人“不假思索”地以为利用bytes.Buffer会更快，类比Java中的StringBuilder完成字符串拼接, bytes.Buffer减少了字符串对象的创建，但是就速度上来说，真的快么。下面来测试一下。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">  <span class="string">"fmt"</span></div><div class="line">  <span class="string">"time"</span></div><div class="line">  <span class="string">"bytes"</span></div><div class="line">  <span class="string">"strings"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">  word := <span class="string">"Alice"</span></div><div class="line"></div><div class="line">  times := <span class="number">1</span></div><div class="line"></div><div class="line">  fmtStr := <span class="string">""</span></div><div class="line">  sTime := time.Now().UnixNano()</div><div class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; times; i++ &#123;</div><div class="line">    fmtStr = fmt.Sprintf(<span class="string">"%s %s"</span>, fmtStr, word)</div><div class="line">  &#125;</div><div class="line">  fmt.Println(<span class="string">"fmt.Sprintf cost "</span>, time.Now().UnixNano()-sTime, <span class="string">" ns; "</span>, <span class="string">" string len: "</span>, <span class="built_in">len</span>(fmtStr))</div><div class="line"></div><div class="line">  fmtStr = <span class="string">""</span></div><div class="line">  sTime = time.Now().UnixNano()</div><div class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; times; i++ &#123;</div><div class="line">    fmtStr = fmtStr + <span class="string">" "</span> + word</div><div class="line">  &#125;</div><div class="line">  fmt.Println(<span class="string">"+ cost "</span>, time.Now().UnixNano()-sTime, <span class="string">" ns; "</span>, <span class="string">" string len: "</span>, <span class="built_in">len</span>(fmtStr))</div><div class="line"></div><div class="line">  fmtStr = <span class="string">""</span></div><div class="line">  sTime = time.Now().UnixNano()</div><div class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; times; i++ &#123;</div><div class="line">    fmtStr = strings.Join([]<span class="keyword">string</span>&#123;fmtStr, word&#125;, <span class="string">" "</span>)</div><div class="line">  &#125;</div><div class="line">  fmt.Println(<span class="string">"string.Join cost "</span>, time.Now().UnixNano()-sTime, <span class="string">" ns; "</span>, <span class="string">" string len: "</span>, <span class="built_in">len</span>(fmtStr))</div><div class="line"></div><div class="line">  <span class="keyword">var</span> buf bytes.Buffer</div><div class="line">  sTime = time.Now().UnixNano()</div><div class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; times; i++ &#123;</div><div class="line">    buf.WriteString(<span class="string">" "</span>)</div><div class="line">    buf.WriteString(word)</div><div class="line">  &#125;</div><div class="line">  fmt.Println(<span class="string">"buf.write cost "</span>, time.Now().UnixNano()-sTime, <span class="string">" ns; "</span>, <span class="string">" string len: "</span>, <span class="built_in">len</span>(buf.String()))</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>&emsp;&emsp;利用4种方法拼接一个没有意义的串。为了验证字符串长度对4种方法拼接速度的影响，利用一个<code>times</code>变量来达到控制字符串长度的目的。开搞~  </p><hr><p>&emsp;&emsp;搞完了，得到下面的数据(以bytes.Buffer为基准)  </p><table><thead><tr><th style="text-align:center">times</th><th style="text-align:center">strings.Join</th><th style="text-align:center">+</th><th style="text-align:center">fmt.Sprintf</th><th style="text-align:center">bytes.Buffer</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">11.07</td><td style="text-align:center">0.13</td><td style="text-align:center">0.14</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">6.56</td><td style="text-align:center">0.13</td><td style="text-align:center">0.13</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">11.99</td><td style="text-align:center">0.29</td><td style="text-align:center">0.19</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">9.72</td><td style="text-align:center">0.24</td><td style="text-align:center">0.17</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">11.55</td><td style="text-align:center">0.33</td><td style="text-align:center">0.30</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">10.99</td><td style="text-align:center">0.43</td><td style="text-align:center">0.37</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">50</td><td style="text-align:center">8.55</td><td style="text-align:center">0.62</td><td style="text-align:center">0.83</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">60</td><td style="text-align:center">9.02</td><td style="text-align:center">0.59</td><td style="text-align:center">1.22</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">70</td><td style="text-align:center">10.48</td><td style="text-align:center">1.12</td><td style="text-align:center">1.23</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">80</td><td style="text-align:center">8.52</td><td style="text-align:center">1.61</td><td style="text-align:center">2.06</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">90</td><td style="text-align:center">14.46</td><td style="text-align:center">2.78</td><td style="text-align:center">2.80</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">100</td><td style="text-align:center">10.23</td><td style="text-align:center">3.17</td><td style="text-align:center">1.93</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">200</td><td style="text-align:center">6.03</td><td style="text-align:center">2.75</td><td style="text-align:center">2.26</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">300</td><td style="text-align:center">17.77</td><td style="text-align:center">11.55</td><td style="text-align:center">12.49</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">400</td><td style="text-align:center">16.66</td><td style="text-align:center">14.52</td><td style="text-align:center">18.79</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">500</td><td style="text-align:center">29.23</td><td style="text-align:center">20.27</td><td style="text-align:center">23.09</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">1000</td><td style="text-align:center">55.57</td><td style="text-align:center">37.24</td><td style="text-align:center">20.99</td><td style="text-align:center">1</td></tr></tbody></table><p>&emsp;&emsp;在拼接很短的字符串时，bytes.Buffer并没有体现出速度的优势，处于使用上的便捷，直接用“+”拼接貌似更舒心些。当然了，在大量字符串拼接的应用场景下，老老实实地使用bytes.Buffer吧，没毛病。  </p><p>以上。</p>]]></content:encoded>
      
      <comments>http://xuyangyang.xyz/2017/11/15/golang-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
