---
title: Golang结构体方法
date: 2017-11-27 22:28:02
tags:
 - Golang
categories:
- 技术
---
&emsp;&emsp;在Golang 中，通过为结构体绑定方法，可以令其扮演Java中“类”的角色。举个简单的例子：  
<!-- more -->
  
	```golang
	package main
	
	import "fmt"
	
	type animal interface {
	  Speak()
	  Sing()
	}
	
	type cat struct {
	  name string
	}
	
	func (c *cat) Speak() {
	  fmt.Printf("I am %v\n", c.name)
	}
	
	func (c cat) Sing() {
	  fmt.Printf("Meow~ Meow~~ Meow~~~ %v is me\n", c.name)
	}
	
	func main() {
	  kitty := &cat{name: "kitty"}
	  kitty.Speak()
	  kitty.Sing()
	
	  alice := cat{name: "alice"}
	  alice.Speak()
	  alice.Sing()
	}
	
	#输出结果：
	I am kitty
	Meow~ Meow~~ Meow~~~ kitty is me
	I am alice
	Meow~ Meow~~ Meow~~~ alice is me
	```
&emsp;&emsp;我们可以将方法绑定到struct对象或者对象指针上，概括起来：通过值类型或引用类型来定义方法。无论使用哪种方式，在使用的时候，Golang可以帮我们完成类型的转换，即：我们可以用指针对象调用值类型的方法，也可以用值类型调用绑定在引用类型上的方法。引用类型定义方法有两个好处：
1. 可以减少对“大”对象的复制，某些情况下可以提高效率
2. 可以修改绑定的struct对象的字段  

&emsp;&emsp;再来个例子：
	 ```golang
	package main
	
	import "fmt"
	
	type animal interface {
	  Speak()
	  Sing()
	  SetName(name string)
	  SetAge(age int)
	}
	
	type cat struct {
	  name string
	  age  int
	}
	
	func (c *cat) Speak() {
	  fmt.Printf("I am %v & I am %v years old\n", c.name, c.age)
	}
	
	func (c cat) Sing() {
	  fmt.Printf("Meow~ Meow~~ Meow~~~ %v is me\n", c.name)
	}
	
	func (c *cat) SetName(name string) {
	  c.name = name
	}
	
	func (c cat) SetAge(age int) {
	  c.age = age
	}
	
	func main() {
	  kitty := &cat{name: "kitty", age: 1}
	  kitty.Speak()
	  kitty.SetName("hello kitty")
	  kitty.SetAge(3)
	  kitty.Speak()
	}
	
	输出结果：
	I am kitty & I am 1 years old
	I am hello kitty & I am 1 years old
	```
&emsp;&emsp;上例中，SetName是定义在引用类型上的，SetAge是定义在值类型上的。那么，对“kitty”对象调用这两个方法，只有SetName成功的修改了kitty的字段值。  
&emsp;&emsp;既然提到了struct实现interface方法，那么再额外探索下interface机制。
	```golang
	package main
	
	import "fmt"
	
	type animal interface {
	  Speak()
	  Sing()
	}
	
	type cat struct {
	  name string
	  age  int
	}
	
	func (c *cat) Speak() {
	  fmt.Printf("I am %v & I am %v years old\n", c.name, c.age)
	}
	
	func (c cat) Sing() {
	  fmt.Println("Meow~ Meow!")
	}
	
	func DoSpeak(baby animal) {
	  baby.Speak()
	}
	
	func DoSing(baby animal) {
	  baby.Sing()
	}
	
	func main() {
	  kitty := &cat{name: "kitty", age: 1}
	  DoSpeak(kitty)
	  DoSing(kitty)
	
	  alice := cat{name: "alice", age: 2}
	  DoSpeak(alice)
	  DoSing(alice)
	}
	```
&emsp;&emsp;上述代码是无法通过编译的，报错信息如下：    

> ./main4.go:37:10: cannot use alice (type cat) as type animal in argument to DoSpeak: cat does not implement animal (Speak method has pointer receiver)
> ./main4.go:38:9: cannot use alice (type cat) as type animal in argument to DoSing: cat does not implement animal (Speak method has pointer receiver)  

&emsp;&emsp;我在[这篇文章][1]里也遇到了这个问题，这里一并记录下。  
&emsp;&emsp;报错信息的意思是alice对象并没有实现animal接口，但是好奇怪呃，struct已经是实现了animal接口了才对。这里就是比较trick的地方了。按照上面的例子来看，我以为绑定到struct对象和对象指针上的方法效果是一样的，其实不然。一旦涉及到使用interface的“多态性”，事情就变味了，某些“本质”的东西就暴露出来了。  
&emsp;&emsp; Golang中，值类型的对象实际上只会有定义在值类型上的方法；引用类型的对象同时拥有定义在引用类型上的方法和定义在值类型上的方法。那么疑问来了，为啥刚才值类型对象可以调用定义在引用类型上的方法呢，Golang的编译器比较“智能”，它主动帮忙把对象类型转成了&引用的形式来调用相应的方法，但是实际上，值类型还是没有引用类型的方法。  
&emsp;&emsp;由此可见，只有用引用类型去实现接口时，才算是“真正低”实现该接口（无论值类型还是引用类型都可以调用相应的方法）；倘若用值类型来实现接口，那么，引用类型是没有相应的方法的，也就是没有实现相应的接口了。这就解释了为啥alice没有实现animal接口了，因为Speak方法是定义在struct引用类型上的，作为值类型的alice是不会拥有Speak方法滴。与此相反，虽然Sing方法是定义在值类型上的，但是由于kitty是引用类型，它还是拥有该方法的。  

[1]:	http://xuyangyang.xyz/2017/11/16/Golang%E2%80%9C%E7%BB%A7%E6%89%BF%E2%80%9D/