---
title: golang 字符串拼接
date: 2017-11-15 10:41:47
tags:
  - golang
categories:
  - 学习
  - 技术
---

&emsp;&emsp; Golang中的字符串拼接方式“大概”有4种：

<!-- more -->

1. \+ 
2. fmt.Sprintf
3. strings.Join
4. bytes.Buffer

&emsp;&emsp;好多人“不假思索”地以为利用bytes.Buffer会更快，类比Java中的StringBuilder完成字符串拼接, bytes.Buffer减少了字符串对象的创建，但是就速度上来说，真的快么。下面来测试一下。

```
package main

import (
  "fmt"
  "time"
  "bytes"
  "strings"
)

func main() {
  word := "Alice"

  times := 1

  fmtStr := ""
  sTime := time.Now().UnixNano()
  for i := 0; i < times; i++ {
    fmtStr = fmt.Sprintf("%s %s", fmtStr, word)
  }
  fmt.Println("fmt.Sprintf cost ", time.Now().UnixNano()-sTime, " ns; ", " string len: ", len(fmtStr))

  fmtStr = ""
  sTime = time.Now().UnixNano()
  for i := 0; i < times; i++ {
    fmtStr = fmtStr + " " + word
  }
  fmt.Println("+ cost ", time.Now().UnixNano()-sTime, " ns; ", " string len: ", len(fmtStr))

  fmtStr = ""
  sTime = time.Now().UnixNano()
  for i := 0; i < times; i++ {
    fmtStr = strings.Join([]string{fmtStr, word}, " ")
  }
  fmt.Println("string.Join cost ", time.Now().UnixNano()-sTime, " ns; ", " string len: ", len(fmtStr))

  var buf bytes.Buffer
  sTime = time.Now().UnixNano()
  for i := 0; i < times; i++ {
    buf.WriteString(" ")
    buf.WriteString(word)
  }
  fmt.Println("buf.write cost ", time.Now().UnixNano()-sTime, " ns; ", " string len: ", len(buf.String()))
}
```
&emsp;&emsp;利用4种方法拼接一个没有意义的串。为了验证字符串长度对4种方法拼接速度的影响，利用一个`times`变量来达到控制字符串长度的目的。开搞\~  

---
&emsp;&emsp;搞完了，得到下面的数据(以bytes.Buffer为基准)  

|  times | strings.Join |    \+    | fmt.Sprintf | bytes.Buffer |
|  :--:  |    :--:      |   :--:   |     :--:    |     :--:     |
|    1   |    11.07     |   0.13   |     0.14    |       1      |
|    2   |     6.56     |   0.13   |     0.13    |       1      |
|    3   |    11.99     |   0.29   |     0.19    |       1      |
|    4   |     9.72     |   0.24   |     0.17    |       1      |
|    5   |    11.55     |   0.33   |     0.30    |       1      |
|   10   |    10.99     |   0.43   |     0.37    |       1      |
|   50   |     8.55     |   0.62   |     0.83    |       1      |
|   60   |     9.02     |   0.59   |     1.22    |       1      |
|   70   |    10.48     |   1.12   |     1.23    |       1      |
|   80   |     8.52     |   1.61   |     2.06    |       1      |
|   90   |    14.46     |   2.78   |     2.80    |       1      |
|  100   |    10.23     |   3.17   |     1.93    |       1      |
|  200   |     6.03     |   2.75   |     2.26    |       1      |
|  300   |    17.77     |  11.55   |    12.49    |       1      |
|  400   |    16.66     |  14.52   |    18.79    |       1      |
|  500   |    29.23     |  20.27   |    23.09    |       1      |
| 1000   |    55.57     |  37.24   |    20.99    |       1      |
  
&emsp;&emsp;在拼接很短的字符串时，bytes.Buffer并没有体现出速度的优势，处于使用上的便捷，直接用“+”拼接貌似更舒心些。当然了，在大量字符串拼接的应用场景下，老老实实地使用bytes.Buffer吧，没毛病。