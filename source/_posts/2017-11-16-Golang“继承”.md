---
title: Golang“继承”
date: 2017-11-16 14:28:12
tags:
 - Golang
 - 偷师
categories:
 - 技术
 - 学习
---
&emsp;&emsp;声明：本文受文章[Golang中的面向对象继承][1]启发，整理而来。
&emsp;&emsp;Golang 并不是一门面向对象的语言，自然也就没有“继承”的概念。但是，从Java转到Golang，还是有办法实现extends的。
<!-- more -->
&emsp;&emsp;Golang中实现继承主要是借助“嵌入”（embeded）来完成的，通过在“子类”中嵌入“父类”的匿名字段来完成目的。
	```golang
	package main
	import (
	  "fmt"
	)
	
	type Base struct {
	  name string
	}
	
	func (b *Base) String() string {
	  return "hello, I am " + b.name
	}
	
	type Sub struct {
	  Base
	  age int
	}
	
	func (s *Sub) String() string {
	  return s.Base.String() + fmt.Sprintf(" & I am %v years old", s.age)
	}
	
	func main() {
	  foo := Sub{Base: Base{name: "alice"}, age: 3}
	  fmt.Println(foo.String())
	}  
	输出结果：
	hello, I am alice & I am 3 years old
	```

&emsp;&emsp;利用struct的嵌入，可以实现基本的重载特性，子类可以重用父类的字段及方法。例如上例中Sub类拥有父类的name字段，并重写了父类的String方法。但是这种实现重载的方式有个问题。如果被重载的方法时被另外的方法调用的，那么，调用结果就会与预期不符。例如：  
    package main
	```golang
	import (
	  "fmt"
	)
	
	type Base struct {
	  name string
	}
	
	func (b *Base) String() string {
	  return "hello, I am " + b.name
	}
	
	func (b *Base) Print() {
	  fmt.Println(b.String())
	}
	
	type Sub struct {
	  Base
	  age int
	}
	
	func (s *Sub) String() string {
	  return s.Base.String() + fmt.Sprintf(" & I am %v years old", s.age)
	}
	
	func main() {
	  foo := Sub{Base: Base{name: "alice"}, age: 3}
	  fmt.Println(foo.String())
	  foo.Print()
	}
	输出结果：
	hello, I am alice & I am 3 years old
	hello, I am alice
	```
&emsp;&emsp;我们在父类Base中加入了一个Print方法。从Java的开发经验来预测，我们期望的输出结果应该是：
	hello, I am alice & I am 3 years old
	hello, I am alice & I am 3 years old
即：Print方法应该是具有“动态绑定”的特性，可以动态地选择它所调用的String方法。子类Sub虽然拥有从父类Base继承来的Print方法，但是这个Print方法时父类带有父类“特征”的，它是和父类的String方法强绑定的。Golang 从根本上阻止了抽象方法的使用 那么，有无破解之道呢？先看代码：
	```golang
	package main
	import (
	  "fmt"
	)
	
	type I interface {
	  String() string
	}
	
	type Base struct {
	  i    I
	  name string
	}
	
	func (b *Base) String() string {
	  return "hello, I am " + b.name
	}
	
	func (b *Base) Print() {
	  fmt.Println(b.i.String())
	}
	
	type Sub struct {
	  Base
	  age int
	}
	
	func (s *Sub) String() string {
	  return s.Base.String() + fmt.Sprintf(" & I am %v years old", s.age)
	}
	
	func main() {
	  foo := Sub{Base: Base{name: "alice"}, age: 3}
	  foo.i = &foo
	  fmt.Println(foo.String())
	  foo.Print()
	}
	输出结果：
	hello, I am alice & I am 3 years old
	hello, I am alice & I am 3 years old
	```
&emsp;&emsp;将String方法作为interface封装起来，将interface作为父类的一个属性，然后在Print方法中通过对interface属性的调用，完成原有功能。总结起来，解决办法是将需要重载的方法作为一个“属性”，这样就可以通过对其动态赋值，达到动态选择的目的了。没办法，只有这种曲线救国的方法可以达到对重载方法的动态选择的目的了。  
&emsp;&emsp;可是，还有一个问题。按照“面向对象”的思想，子类继承父类，那么任何需要父类的地方，按理说都可以用子类来代替。子类是父类的特化嘛，这不就是“多态”嘛？很遗憾，Golang又让你失望了。
	```golang
	package main
	import (
	  "fmt"
	)
	
	type I interface {
	  String() string
	}
	
	type Base struct {
	  i    I
	  name string
	}
	
	func (b *Base) String() string {
	  return "hello, I am " + b.name
	}
	
	func (b *Base) Print() {
	  fmt.Println(b.i.String())
	}
	
	type Sub struct {
	  Base
	  age int
	}
	
	func (s *Sub) String() string {
	  return s.Base.String() + fmt.Sprintf(" & I am %v years old", s.age)
	}
	
	func Info(b Base) {
	  b.Print()
	}
	
	func main() {
	  foo := Sub{Base: Base{name: "alice"}, age: 3}
	  foo.i = &foo
	  Info(foo)
	}
	输出结果：
	cannot use foo (type Sub) as type Base in argument to Info
	```
&emsp;&emsp;呵呵哒，剧本貌似不是这么写的。没办法吗？提前剧透：Golang的接口类型有子类化的多态机制。所以，再次曲线救国吧\~ 
	```golang
	package main
	import (
	  "fmt"
	)
	
	type I interface {
	  String() string
	}
	
	type iBase interface{
	  String() string
	  Print()
	}
	
	type Base struct {
	  i    I
	  name string
	}
	
	func (b *Base) String() string {
	  return "hello, I am " + b.name
	}
	
	func (b *Base) Print() {
	  fmt.Println(b.i.String())
	}
	
	type Sub struct {
	  Base
	  age int
	}
	
	func (s *Sub) String() string {
	  return s.Base.String() + fmt.Sprintf(" & I am %v years old", s.age)
	}
	
	func Info(b iBase) {
	  b.Print()
	}
	
	func main() {
	  foo := Sub{Base: Base{name: "alice"}, age: 3}
	  foo.i = &foo
	  Info(&foo)
	}
	输出结果：
	hello, I am alice & I am 3 years old
	```
&emsp;&emsp;把父类对应的方法都封装到interface里吧，让父类去实现这个接口。子类如果需要“扩展”方法，同样可以利用嵌入的方式，生成子类自己的接口。这样就可以利用接口来实现继承中的多态了。注意，Info方法的参数是iBase接口，在用子类对象foo调用这个方法时，需要传递foo对象的引用。为了这个纠结了好久，这个问题回头另起一篇记录下。  

[1]:	http://hackthology.com/golangzhong-de-mian-xiang-dui-xiang-ji-cheng.html